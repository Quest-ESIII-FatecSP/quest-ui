<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Jogo de Quiz ‚Äî Jogador vs Jogador</title>
<style>
  body {
    margin: 0;
    font-family: 'Poppins', sans-serif;
    color: white;
    overflow: hidden;
    background: #000 url('Fundo.jpeg') center center / cover no-repeat fixed;
  }

  .bg-style-intense {
    background-color: #2a0b2b;
    background-image:
      linear-gradient(135deg, rgba(255,255,255,0.07) 25%, transparent 25%),
      linear-gradient(225deg, rgba(255,255,255,0.05) 25%, transparent 25%),
      radial-gradient(circle at 10% 10%, rgba(255,255,255,0.04), transparent 18%);
    background-size: 40px 40px, 40px 40px, 1000px 600px;
    background-position: 0 0, 20px 20px, center center;
    background-blend-mode: overlay, overlay, normal;
  }
  .bg-style-smooth {
    background-color: #301033;
    background-image:
      linear-gradient(135deg, rgba(255,255,255,0.03) 25%, transparent 25%),
      linear-gradient(225deg, rgba(255,255,255,0.02) 25%, transparent 25%),
      radial-gradient(circle at 10% 10%, rgba(255,255,255,0.03), transparent 18%);
    background-size: 48px 48px, 48px 48px, 1000px 600px;
    background-position: 0 0, 24px 24px, center center;
    background-blend-mode: overlay, overlay, normal;
  }

    #backgroundCanvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -2;
    }
    .overlay {
      position: fixed;
      top: 0; left: 0; width: 100%; height: 100%;
      background: linear-gradient(135deg, rgba(3,15,60,0.45), rgba(60,15,90,0.45));
      animation: bgshift 12s ease-in-out infinite alternate;
      z-index: -1;
    }
    @keyframes bgshift { 0% { background: linear-gradient(135deg, rgba(3,15,60,0.45), rgba(60,15,90,0.45)); } 100% { background: linear-gradient(135deg, rgba(10,40,100,0.45), rgba(90,20,120,0.45)); } }

    .hidden-icons img { position:absolute; left:-9999px; visibility:hidden }

  .top-bar {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 10px 20px;
    border-bottom: 4px solid #FFD700;
    background-color: #021028;
  }

  .player-info {
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .player-info img {
    width: 45px;
    height: 45px;
    border-radius: 50%;
    object-fit: cover;
  }

  /* --- Brilho / luz de fundo (estilo semelhante √† roleta) --- */
  .player-info img,
  #player1-icon,
  #player2-icon {
    position: relative;
    display: inline-block;
    border-radius: 50%;
    box-shadow: 0 0 60px rgba(255,210,58,0.45), inset 0 0 0 6px rgba(0,0,0,0.35);
    transition: box-shadow .32s ease, transform .25s ease;
  }

  .player-info img::after,
  #player1-icon::after,
  #player2-icon::after {
    content: "";
    position: absolute;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
    width: 160%;
    height: 160%;
    background: radial-gradient(circle at 30% 20%, rgba(255,210,58,0.22), rgba(255,210,58,0.06) 35%, transparent 55%);
    filter: blur(16px);
    z-index: -1;
    border-radius: 50%;
    pointer-events: none;
  }

  @media (prefers-reduced-motion: reduce) {
    .player-info img, #player1-icon, #player2-icon { transition: none; }
    .player-info img::after, #player1-icon::after, #player2-icon::after { filter: blur(6px); }
  }

  .player-name {
    font-size: 16px;
    color: #ddd;
    margin-right: 6px;
  }

  .points {
    font-weight: bold;
    color: #FFD700;
    font-size: 18px;
  }

  .timer-area {
    display: flex;
    align-items: center;
    gap: 10px;
  }

  .timer-container {
    position: relative;
    width: 60px;
    height: 60px;
  }

  .timer-circle {
    fill: none;
    stroke-width: 6;
    transform: rotate(-90deg);
    transform-origin: 50% 50%;
    transition: stroke 0.2s linear;
  }

  .timer-text {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-weight: bold;
    font-size: 18px;
  }

  #help-btn {
    background-color: #1a4cd7;
    color: white;
    border: none;
    padding: 8px 16px;
    border-radius: 10px;
    cursor: pointer;
    font-size: 16px;
    transition: background 0.2s;
  }

  #help-btn:hover { background-color: #163eb3; }

  #help-popup {
    display: none;
    position: absolute;
    top: 70px;
    right: 20px;
    background: #0b164d;
    border: 2px solid #FFD700;
    border-radius: 10px;
    padding: 15px;
    width: 220px;
    z-index: 20;
    flex-direction: column;
    gap: 10px;
    box-shadow: 0 0 15px rgba(0, 0, 0, 0.4);
  }

  #help-popup button {
    background-color: #1a4cd7;
    color: white;
    border: none;
    padding: 8px;
    border-radius: 8px;
    font-size: 15px;
    cursor: pointer;
  }

  #help-popup button:hover { background-color: #163eb3; }

  #game-area {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    height: calc(100vh - 74px);
    text-align: center;
    gap: 20px;
  }

  .btn {
    background-color: #1a4cd7;
    color: white;
    padding: 12px 30px;
    border: none;
    border-radius: 10px;
    font-size: 18px;
    cursor: pointer;
    transition: background 0.2s;
  }

  .btn:hover { background-color: #163eb3; }

  #cards { position: fixed; inset:0; pointer-events:none; z-index:3; }
  .cards-side{ position:fixed; top:50%; transform:translateY(-50%); display:flex; flex-direction:column; gap:16px; }
  .cards-side.left{ left:16px; }
  .cards-side.right{ right:16px; }
  .cards-stack{ display:flex; flex-direction:row; column-gap:16px; }
  .cards-stack .cards-col{ display:flex; flex-direction:column; gap:16px; align-items:center; }
  .cards-side .card{ width:100px; height:150px; }
  @media (max-height: 860px){ .cards-side .card{ width:92px; height:138px; } }
  @media (max-height: 760px){ .cards-side .card{ width:86px; height:129px; } }
  @media (max-height: 680px){ .cards-side .card{ width:82px; height:124px; } }
  /* T√≠tulo centralizado no topo */
  #category.centered-title{ width: 100%; text-align: center; font-weight: 700; }

  .card {
    width: 100px;
    height: 150px;
    background: linear-gradient(145deg, #1a1f4b, #0b0f30);
    border: 2px solid #FFD700;
    border-radius: 15px;
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 32px;
    cursor: pointer;
    transition: transform 0.25s ease, box-shadow 0.25s ease;
  }
  .card.card-used{
    background: linear-gradient(145deg, #fff1a8, #ffd23a);
    color: #000 !important; /* for√ßa texto preto quando usada */
    cursor: not-allowed;
    filter: saturate(1.05);
  }

  .card-inner {
    width: 100%; height: 100%; position: relative; transform-style: preserve-3d; transition: transform 600ms cubic-bezier(.2,.9,.3,1);
    border-radius: 12px; display: flex; align-items: center; justify-content: center;
  }
  .card-face { position: absolute; inset: 0; display:flex; align-items:center; justify-content:center; backface-visibility: hidden; border-radius: 12px; }
  .card-front { background: linear-gradient(145deg, #1a1f4b, #0b0f30); color: transparent; }
  .card-back { background: linear-gradient(145deg, #fff9e6, #ffd23a); color: #1a1200; transform: rotateY(180deg); font-weight:900; font-size:34px }
  .card-inner.flipped { transform: rotateY(180deg); }

  .card:hover {
    transform: translateY(-12px);
    box-shadow: 0 0 16px rgba(255, 215, 0, 0.45);
  }

  .card-vibe { width:100%; height:100%; display:flex; align-items:center; justify-content:center; }
  .card-vibe.vibrate { animation: vibrate 900ms infinite; }
  @keyframes vibrate {
    0% { transform: translateX(0) rotate(0.0deg); }
    25% { transform: translateX(-1.8px) rotate(-0.6deg); }
    50% { transform: translateX(0.8px) rotate(0.4deg); }
    75% { transform: translateX(-0.6px) rotate(-0.3deg); }
    100% { transform: translateX(0) rotate(0.0deg); }
  }


  #question-area {
    display: none;
    flex-direction: column;
    align-items: center;
    gap: 15px;
    max-width: 720px;
    /* subir ainda mais a janela da pergunta/alternativas */
    margin-top: -90px;
  }

  /* Caixa de pergunta com o mesmo visual do popup da roleta */
  #question-box.fw-modal-like { width: clamp(480px, 85vw, 860px); padding-left:24px; padding-right:24px; }
  .qp-header{ display:flex; flex-wrap:wrap; align-items:center; justify-content:space-between; gap:8px; margin-bottom:10px }
  .turn-title{ font-weight:700; color:#FFD700 }
  .current-player-title{ font-weight:600; color:#ddd }

  /* Badge de categoria dentro da caixa de pergunta */
  .cat-badge{
    display:inline-block;
    align-self:flex-start;
    padding:6px 12px;
    margin-bottom:8px;
    border-radius:999px;
    border:2px solid #FFD700;
    background: linear-gradient(145deg, #1a1f4b, #0b0f30);
    color:#FFD700;
    font-weight:700;
    font-size:14px;
    letter-spacing:.3px;
  }

  .question { font-size: 22px; font-weight: bold; }

  .answers {
    display: flex;
    flex-direction: column;
    gap: 8px;
    width: 100%;
  }

  .answers button {
    background-color: #1a4cd7;
    color: white;
    border: none;
    padding: 10px;
    border-radius: 8px;
    font-size: 16px;
    cursor: pointer;
  }

  .answers button:disabled{
    opacity: .6;
    cursor: not-allowed;
    filter: grayscale(25%);
  }

  .answers button:hover { background-color: #163eb3; }
  /* Destaque visual ao responder */
  .answers button.ans-correct{ background-color:#28a745 !important; color:#fff !important; }
  .answers button.ans-wrong{ background-color:#c0392b !important; color:#fff !important; }

  #waiting-screen {
    display: none;
    flex-direction: column;
    gap: 12px;
  }

  .result-animation {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%) scale(0);
    border-radius: 50%;
    color: white;
    font-size: 60px;
    display: flex;
    align-items: center;
    justify-content: center;
    width: 120px;
    height: 120px;
    opacity: 0;
    transition: transform 0.25s ease, opacity 0.25s ease;
    z-index: 10;
  }

  .result-animation.show {
    transform: translate(-50%, -50%) scale(1);
    opacity: 1;
  }

  .result-animation.correct { background-color: rgba(0,200,0,0.85); }
  .result-animation.wrong { background-color: rgba(200,0,0,0.85); }

  :root{ --rot-size:320px; }
  .roleta-wrap{ display:flex; flex-direction:column; align-items:center; gap:8px }
  .roleta{ width:320px; height:320px; position:relative; border-radius:50%; display:grid; place-items:center; }
  .disco{ width:100%; height:100%; border-radius:50%; background:transparent; display:grid; place-items:center; border:10px solid #ffd23a; box-shadow: 0 0 30px rgba(255,210,58,0.25); transform:rotate(0deg); transition: transform 5s cubic-bezier(.17,.89,.32,1.49); }
  .disco.idle{ animation: none }
  .miolo{ position:absolute; width:110px; height:110px; border-radius:50%; background:radial-gradient(circle at 30% 30%, #2a2b3f, #0b0f1f 60%); border:6px solid rgba(0,0,0,0.5); box-shadow: inset 0 2px 12px #000a, 0 8px 18px rgba(0,0,0,.45); z-index:2}
  .girar-central{ position:absolute; z-index:5; top:50%; left:50%; transform:translate(-50%,-50%); width:84px; height:84px; border-radius:50%; display:grid; place-items:center; font-weight:800; cursor:pointer; border:6px solid rgba(0,0,0,0.25); color:#1a1200; background: linear-gradient(180deg,#ffd23a,#d4a200); }
  .pointer-top{ position:absolute; top:-6px; left:50%; transform:translateX(-50%); width:14px; height:14px; border-radius:50%; background:transparent; z-index:5 }

  #roletaModal > div { overflow: visible !important; }
  #roletaModal > div > div { overflow: visible !important; }
  #roletaIframe {
    width: 100%;
    height: 560px;
    border: 0;
    display: block;
    background: transparent;
    transform-origin: 50% 50%;
    animation: none !important; /* sem pulso no iframe */
    transform: none !important;
  }
  /* removido o pulso visual do iframe para manter est√°tico */

  .confetti-container {
    position: fixed;
    left: 0; right: 0; bottom: 0;
    height: 0; pointer-events: none; overflow: visible;
    z-index: 10005;
  }
  .confetti {
    position: absolute; bottom: -12px; width: 10px; height: 16px; opacity: 0.95; border-radius: 2px;
    transform-origin: center;
    animation-name: confettiMove; animation-timing-function: cubic-bezier(.2,.7,.3,1); animation-fill-mode: forwards;
  }
  @keyframes confettiMove {
    0% { transform: translateY(0) rotate(0deg); opacity: 1; }
    60% { opacity: 1; }
    100% { transform: translateY(-110vh) rotate(720deg); opacity: 0; }
  }

  /* Fireworks visuals (DOM + CSS animated) */
  .fireworks-container{
    position: fixed;
    left: 0; top: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10010; overflow: visible;
  }
  .firework-rocket{
    position: absolute; bottom: 12px; width: 6px; height: 12px; border-radius: 3px; background: linear-gradient(180deg,#fff,#ffd23a);
    transform-origin: center bottom; box-shadow: 0 0 8px rgba(255,200,60,0.9);
  }
  .firework-particle{
    position: absolute; width: 8px; height: 8px; border-radius: 50%; opacity: 0; pointer-events: none;
    box-shadow: 0 0 10px rgba(255,255,255,0.9);
  }

  @keyframes fw-rocketUp {
    0% { transform: translateY(0) scale(1); opacity: 1 }
    80% { opacity: 1 }
    100% { transform: translateY(-62vh) scale(0.9); opacity: 0 }
  }

  @keyframes fw-particleFly {
    0% { transform: translate(0,0) scale(1); opacity: 1 }
    100% { transform: translate(var(--dx,0px), var(--dy,0px)) scale(0.6); opacity: 0 }
  }

  /* Final winner modal styles: larger card, aligned icon and roleta-like glow */
  .fw-modal-content {
    background: linear-gradient(180deg,#111,#0e0e12);
    padding: 20px 22px;
    border-radius: 18px;
    border: 4px solid #FFD700;
    color: #fff;
    min-width: 360px;
    max-width: 680px;
    width: clamp(360px, 60vw, 680px);
    display: flex;
    gap: 18px;
    align-items: center;
    justify-content: center;
    position: relative;
    box-shadow: 0 12px 40px rgba(0,0,0,0.6);
  }
  .fw-modal-content::before{
    content: "";
    position: absolute;
    inset: -8px;
    border-radius: 20px;
    background: radial-gradient(circle at 30% 20%, rgba(255,210,58,0.06), transparent 40%);
    filter: blur(18px);
    z-index: -1;
    pointer-events: none;
  }
  .fw-modal-icon{
    width: 140px;
    height: 140px;
    border-radius: 50%;
    object-fit: cover;
    flex-shrink: 0;
    box-shadow: 0 0 60px rgba(255,210,58,0.45), inset 0 0 0 6px rgba(0,0,0,0.35);
  }
  /* make modal responsive: stack vertically on narrow screens */
  @media (max-width:520px){
    .fw-modal-content{ flex-direction: column; padding:16px; }
    .fw-modal-icon{ width:120px; height:120px; }
  }

  /* Roleta modal visual igual ao do fim da partida (apenas largura maior p/ iframe) */
  .fw-modal-like{
    background: linear-gradient(180deg,#111,#0e0e12);
    padding: 16px 18px 20px;
    border-radius: 18px;
    border: 4px solid #FFD700;
    color: #fff;
    width: clamp(420px, 82vw, 780px);
    position: relative;
    box-shadow: 0 12px 40px rgba(0,0,0,0.6);
    overflow: visible;
  }
  .fw-modal-like::before{
    content: "";
    position: absolute;
    inset: -8px;
    border-radius: 20px;
    background: radial-gradient(circle at 30% 20%, rgba(255,210,58,0.06), transparent 40%);
    filter: blur(18px);
    z-index: -1;
    pointer-events: none;
  }
  /* Overlay para o observador (n√£o √© a vez) sobre a roleta */
  #roletaOverlay{
    position:absolute; inset:0; display:none; align-items:center; justify-content:center;
    background: rgba(0,0,0,0.45); color:#fff; font-weight:800;
    font-size: clamp(16px, 2.8vw, 24px); text-align:center; text-shadow:0 2px 6px #000;
    z-index: 20; /* acima do iframe */
  }
  #roletaIframe.dim{ filter: brightness(0.6) saturate(0.9); }

  /* Barra de poderes na parte inferior, mesma est√©tica das cartas */
  .power-tray{ position:fixed; bottom:16px; display:none; z-index:5000 }
  .power-tray.center{ left:50%; transform:translateX(-50%); }
  .power-tray.right{ right:16px; left:auto; transform:none; }
  .power-tray.left{ left:16px; right:auto; transform:none; }
  .power-row{ display:flex; align-items:center; justify-content:center; gap:12px }
  .power-btn{
    width:84px; height:84px; border-radius:50%;
    border:2px solid #FFD700; color:#fff; cursor:pointer;
    background: linear-gradient(145deg, #1a1f4b, #0b0f30);
    box-shadow: 0 0 16px rgba(255, 215, 0, 0.25);
    display:grid; place-items:center; font-weight:900; font-size:22px;
    transition: transform .22s ease, box-shadow .22s ease, filter .22s ease;
  }
  .power-btn:hover{ transform: translateY(-6px); box-shadow: 0 0 20px rgba(255, 215, 0, 0.38); filter: brightness(1.06) }
  .power-btn:disabled{ opacity:.6; cursor:not-allowed; filter: grayscale(25%); }
  .power-btn--freeze{ font-size:24px }
  .power-btn--steal{ background: linear-gradient(145deg, #fff1a8, #ffd23a); color:#1a1200; border-width:3px; box-shadow: 0 0 24px rgba(255,210,58,0.45); font-size:15px; line-height:1.15; font-weight:800; padding:6px 12px; text-align:center; }
  .power-btn--steal span{ display:block; text-align:center; }
    /* Classe para bot√µes que N√ÉO sincronizam visualmente entre jogadores (s√≥ local) */
    .power-btn.local-only.hidden-remote{ display:none !important; }
  /* Fixar apenas o bot√£o "Roubar Pergunta" no centro inferior da tela */
  #btn-steal{
    position: fixed;
    left: 50%;
    bottom: 24px;
    transform: translateX(-50%);
    z-index: 6000; /* acima da barra de poderes */
  }
  /* aumentar tamanho do bot√£o roubar pergunta sem afetar os outros */
  #btn-steal.power-btn{ width: 100px; height: 100px; }
  @media (max-height: 760px){
    .power-btn{ width:72px; height:72px; font-size:20px }
    .power-btn--steal{ font-size:12px }
  }
  @media (max-height: 680px){
    .power-btn{ width:66px; height:66px; font-size:18px }
    .power-btn--steal{ font-size:11px }
  }
</style>
</head>

<div class="top-bar">
  <div class="player-info">
    <img id="player1-icon" src="https://i.pravatar.cc/50?img=3" />
    <span class="player-name" id="player1-name">Jogador1</span>
    <span class="points" id="player1-points">0 pts</span>
  </div>

  <div class="timer-area">
    <div class="timer-container">
      <svg width="60" height="60">
        <circle cx="30" cy="30" r="27" stroke="#333" />
        <circle id="timer-circle" class="timer-circle" cx="30" cy="30" r="27" stroke="#00FF00" stroke-dasharray="170" stroke-dashoffset="0" />
      </svg>
      <div id="timer-text" class="timer-text">15</div>
    </div>
    <button id="help-btn">Ajuda</button>
    <button id="backBtn" title="Voltar ao Lobby" style="margin-left:8px;padding:6px 8px;border-radius:8px;border:none;cursor:pointer;background:#2b2b5a;color:#fff">Voltar ao Lobby</button>
  </div>

  <div class="player-info">
    <img id="player2-icon" src="https://i.pravatar.cc/50?img=5" />
    <span class="player-name" id="player2-name">Jogador2</span>
    <span class="points" id="player2-points">0 pts</span>
  </div>
</div>

<div id="help-popup">
  <button>üí° Dica</button>
  <button>üë• Mudar pergunta</button>
  <button>‚è© Pular Quest√£o</button>
  <button>üìä Eliminar alternativa</button>
</div>

<div id="game-area">
  <div id="category" style="min-height:22px;"></div>
  <div id="roleta-area" style="display:flex;flex-direction:column;align-items:center;gap:12px;margin-top:-40px;">
    <div class="fw-modal-like" style="overflow:visible;position:relative;">
      <iframe id="roletaIframe" src="roleta.html"></iframe>
      <div id="roletaOverlay">O oponente est√° girando a roleta</div>
    </div>
  </div>
  <div id="cards"></div>
  <div id="question-area">
    <div id="question-box" class="fw-modal-like" style="display:flex;flex-direction:column;gap:10px;">
      <div id="cat-badge" class="cat-badge" style="display:none"></div>
      <div class="qp-header">
        <div id="turn-title" class="turn-title"></div>
        <div id="current-player-title" class="current-player-title"></div>
      </div>
      <div class="question" id="question"></div>
      <div class="answers" id="answers"></div>
    </div>
  </div>
  <div id="waiting-screen">
    <h2 style="display:none"></h2>
    <p id="opponent-category" style="display:none"></p>
  </div>
</div>

<div id="result-animation" class="result-animation"></div>

<!-- Barra de poderes (UI) -->
<div id="power-tray" class="power-tray center" aria-label="Poderes dispon√≠veis">
  <div class="power-row">
    <button class="power-btn power-btn--freeze local-only" id="btn-freeze" title="Congelar quest√£o">üßä</button>
    <button class="power-btn local-only" title="Poder">P</button>
    <button class="power-btn local-only" title="Poder">P</button>
    <button class="power-btn local-only" title="Poder">P</button>
    <button class="power-btn local-only" title="Poder">P</button>
    <button class="power-btn power-btn--steal" id="btn-steal" title="Roubar Pergunta"><span>Roubar<br>Pergunta</span></button>
  </div>
  <!-- Observa√ß√£o: apenas UI/est√©tica. L√≥gica funcional poder√° ser adicionada depois. -->
  </div>

<script>
const helpBtn = document.getElementById('help-btn');
const helpPopup = document.getElementById('help-popup');
helpBtn.addEventListener('click', () => {
  helpPopup.style.display = helpPopup.style.display === 'flex' ? 'none' : 'flex';
});
document.addEventListener('click', (e) => {
  if (!helpBtn.contains(e.target) && !helpPopup.contains(e.target)) helpPopup.style.display = 'none';
});

const backBtn = document.getElementById('backBtn');
if (backBtn) {
  backBtn.addEventListener('click', () => {
    window.location.href = 'players.html';
  });
}

// Poder: Congelar (üßä) ‚Äî o oponente congela o jogador da vez por 5s
(function initFreezePower(){
  try{
    const freezeBtn = document.getElementById('btn-freeze');
    if(freezeBtn){
      freezeBtn.addEventListener('click', ()=>{
        try{
          // S√≥ o oponente pode usar durante a pergunta
          const qa = document.getElementById('question-area');
          const isQuestionVisible = qa ? (window.getComputedStyle(qa).display !== 'none') : false;
          if(!isQuestionVisible) return;
          if(localPlayerId === currentPlayer) return;
          const payload = { by: localPlayerId, target: currentPlayer, at: Date.now(), durationMs: 5000 };
          localStorage.setItem('power_freeze', JSON.stringify(payload));
        }catch(e){}
      });
    }
  }catch(e){}
})();

// Poder: Trocar alternativa correta de lugar (button ao lado do gelo)
(function initShufflePower(){
  try{
    // Pegar o primeiro bot√£o 'P' local-only que n√£o √© o freeze
    const btn = document.querySelector('.power-row .power-btn.local-only:not(#btn-freeze)');
    if(btn){
      if(!btn.id) btn.id = 'btn-shuffle-correct';
      btn.title = 'Trocar alternativa correta de lugar';
      btn.addEventListener('click', ()=>{
        try{
          const qa = document.getElementById('question-area');
          const isQuestionVisible = qa ? (window.getComputedStyle(qa).display !== 'none') : false;
          if(!isQuestionVisible) return;
          if(localPlayerId === currentPlayer) return; // somente o oponente usa
          const ctx = window._currentQuestionCtx || {};
          if(!ctx || !ctx.at) return;
          const payload = { by: localPlayerId, target: currentPlayer, qAt: ctx.at, at: Date.now() };
          localStorage.setItem('power_shuffle', JSON.stringify(payload));
        }catch(e){}
      });
    }
  }catch(e){}
})();

// Identidade local do jogador (para simula√ß√£o de 2 telas): use ?p=1 ou ?p=2
const localPlayerId = (() => {
  try { return Math.max(1, Math.min(2, parseInt(new URLSearchParams(location.search).get('p')||'1', 10))); } catch(e){ return 1; }
})();

// Carregar avatar selecionado do localStorage (se houver)
try{
  // Prefer explicit per-player keys; fallback to legacy 'selectedAvatar'
  const stored1 = localStorage.getItem('selectedAvatar1') || localStorage.getItem('selectedAvatar');
  const stored2 = localStorage.getItem('selectedAvatar2');
  if(stored1){
    const p1 = document.getElementById('player1-icon');
    if(p1) p1.src = stored1;
  }
  if(stored2){
    const p2 = document.getElementById('player2-icon');
    if(p2) p2.src = stored2;
  }
}catch(e){ /* localStorage indispon√≠vel */ }

// Atualizar em tempo real caso o avatar seja alterado em outra aba/janela
try{
  window.addEventListener('storage', (ev) => {
    if(!ev) return;
    try{
      if(ev.key === 'selectedAvatar' || ev.key === 'selectedAvatar1'){
        const newSrc = ev.newValue;
        const p1 = document.getElementById('player1-icon');
        if(p1 && newSrc) p1.src = newSrc;
      }
      if(ev.key === 'selectedAvatar2'){
        const newSrc = ev.newValue;
        const p2 = document.getElementById('player2-icon');
        if(p2 && newSrc) p2.src = newSrc;
      }
    }catch(e){}
  });
}catch(e){ /* ignore */ }

let currentPlayer = 1;
let points = {1: 0, 2: 0};
let timer, timeLeft = 15;
let spectatorTimer = null; // contador visual para o oponente (n√£o autoritativo)
// Cache local de cartas usadas por jogador (valores 1..5), separado por player
let usedCardsCache = { 1: [], 2: [] };
// Contador obrigat√≥rio de rodadas (m√°ximo 5)
let roundCount = 0;

function finalizeIfRoundLimitOrWinner(){
  // Se j√° houve vencedor pelos pontos (>=15), nada a fazer extra
  if(points[1] >= 15 || points[2] >= 15) return; // checkForWinner j√° ser√° chamado em fluxo normal
  if(roundCount >= 5){
    // Decide vencedor por maior pontua√ß√£o ap√≥s 5 rodadas
    let winnerId;
    if(points[1] === points[2]){
      winnerId = 1; // crit√©rio m√≠nimo em caso de empate
    } else {
      winnerId = (points[1] > points[2]) ? 1 : 2;
    }
    const winner = { id: winnerId, name: document.getElementById(`player${winnerId}-name`).textContent, pts: points[winnerId] };
    showFinalWinner(winner);
  }
}

const questions = {
  Science: [{question: "Qual planeta √© conhecido como o Planeta Vermelho?", answers: ["V√™nus", "Marte", "J√∫piter", "Saturno", "Merc√∫rio"], correct: 1}],
  History: [{question: "Quem descobriu a Am√©rica?", answers: ["Crist√≥v√£o Colombo", "Fern√£o de Magalh√£es", "Am√©rico Vesp√∫cio", "James Cook", "Marco Polo"], correct: 0}],
  Sports: [{question: "Quantos jogadores tem um time de futebol?", answers: ["9", "10", "11", "12", "13"], correct: 2}],
  Art: [{question: "Quem pintou a Mona Lisa?", answers: ["Picasso", "Van Gogh", "Leonardo da Vinci", "Michelangelo", "Rembrandt"], correct: 2}],
  Movies: [{question: "Em qual filme aparece a frase 'I'll be back'?", answers: ["Rocky", "Predador", "Exterminador do Futuro", "Matrix", "Rambo"], correct: 2}]
};

// Limpa todas as chaves de estado de partida no localStorage
function clearMatchState(){
  try{
    const keys = ['sync_roleta','sync_roleta_spin','sync_card','sync_question','sync_answer','matchResult','goLobbyNow','rematchNow','rematchRequest','rematchResponse','used_cards','used_cards_1','used_cards_2'];
    keys.forEach(k => localStorage.removeItem(k));
  }catch(e){}
}

// Se houver estado final antigo e nenhum estado ativo recente, limpa para evitar ficar preso no fim
function maybeClearStaleState(){
  try{
    // Evitar limpar repetidamente em reloads desta aba
    if(sessionStorage.getItem('freshBoot') === '1') return;
    sessionStorage.setItem('freshBoot','1');
    const now = Date.now();
    const get = (k)=>{ try{ return JSON.parse(localStorage.getItem(k)||'null'); }catch(e){ return null; } };
    const q = get('sync_question');
    const r = get('sync_roleta');
    const s = get('sync_roleta_spin');
    const a = get('sync_answer');
    const m = get('matchResult');
    const recent = (o,ms)=> o && typeof o.at==='number' && (now - o.at) < ms;
    const hasActiveRecent = recent(q, 120000) || recent(r, 120000) || recent(s, 120000) || recent(a, 120000);
    if(m && !hasActiveRecent){
      clearMatchState();
    }
  }catch(e){}
}

// Ao iniciar nova partida pelo lobby, detectar sinal e limpar estado antigo (uma vez por aba)
function applyNewMatchSignal(){
  try{
    const nm = localStorage.getItem('newMatch');
    if(!nm) return;
    const appliedKey = 'newMatchApplied_'+localPlayerId;
    const already = localStorage.getItem(appliedKey);
    if(already === nm) return;
    clearMatchState();
    localStorage.setItem(appliedKey, nm);
  }catch(e){}
}

// Map English category keys to Portuguese labels for display
function englishToPt(cat){
  const map = { 'Science':'Ci√™ncias', 'History':'Sociedade', 'Sports':'Esportes', 'Art':'Artes', 'Movies':'Mundo' };
  return map[cat] || cat;
}

// Renderiza a pergunta para ambas as telas; desabilita respostas para o oponente
function renderQuestionPayload(payload){
  try{
    if(!payload) return;
    const { category, question, answers, correct, pointsValue, by } = payload;

  // Esconde a roleta enquanto a pergunta est√° vis√≠vel
  try{ const ro = document.getElementById('roleta-area'); if(ro) ro.style.display = 'none'; }catch(e){}
  // Mant√©m as cartas vis√≠veis durante a pergunta (intera√ß√£o desabilitada abaixo)
  try{ const cd = document.getElementById('cards'); if(cd) cd.style.display = 'block'; }catch(e){}
    // Mant√©m as cartas vis√≠veis, mas desabilita intera√ß√£o durante a pergunta
    try{ const cd = document.getElementById('cards'); if(cd) cd.style.pointerEvents = 'none'; }catch(e){}

  // Mostra a caixa de pergunta para todos
    const qa = document.getElementById('question-area');
    if(qa) qa.style.display = 'flex';
  try{ setPowerTrayVisible(true); }catch(e){}
  // Reafirma exibi√ß√£o dos poderes do oponente (defensivo contra toggles ass√≠ncronos)
  try{ setTimeout(()=>{ try{ setPowerTrayVisible(true); }catch(e){} }, 0); }catch(e){}

    // T√≠tulo superior (vez ou oponente) e nome do jogador da vez
    const turnTitle = document.getElementById('turn-title');
    const curTitle = document.getElementById('current-player-title');
    const nameEl = document.getElementById(`player${by}-name`);
    const byName = (nameEl && nameEl.textContent) ? nameEl.textContent : `Jogador ${by}`;
    if(localPlayerId === by){
      if(turnTitle) turnTitle.textContent = 'Agora √© sua vez, responda:';
    } else {
      if(turnTitle) turnTitle.textContent = 'Oponente est√° respondendo...';
    }
    if(curTitle) curTitle.textContent = `Jogador da vez: ${byName}`;

    // Categoria opcional no t√≠tulo de categoria j√° existente
  try{
    const catEl = document.getElementById('category');
    if(catEl){ catEl.classList.remove('centered-title'); catEl.innerText = ''; }
    const badge = document.getElementById('cat-badge');
    if(badge){ badge.style.display = 'inline-block'; badge.textContent = `Categoria: ${englishToPt(category)}`; }
  }catch(e){}

    // Pergunta e respostas
    const qEl = document.getElementById('question');
    const ansDiv = document.getElementById('answers');
    if(qEl) qEl.textContent = question || '';
    if(ansDiv){
      ansDiv.innerHTML = '';
      (answers||[]).forEach((ans, idx)=>{
        const btn = document.createElement('button');
        btn.innerText = ans;
        btn.dataset.idx = String(idx);
        if(localPlayerId !== by){
          btn.disabled = true; // oponente v√™, mas n√£o responde
        } else {
          btn.onclick = () => { if(localPlayerId !== currentPlayer) return; answerQuestion(idx === correct, pointsValue, category, idx, correct); };
        }
        ansDiv.appendChild(btn);
      });
      // Se houver congelamento aplicado antes de re-render (ex: hidrata√ß√£o), respeitar storage
      try{
        const freezeRaw = localStorage.getItem('power_freeze');
        if(freezeRaw){
          const f = JSON.parse(freezeRaw||'{}');
          if(f && f.target === currentPlayer && localPlayerId === currentPlayer){
            const since = Date.now() - f.at;
            const remaining = (f.durationMs||5000) - since;
            if(remaining > 0){
              const btns = Array.from(ansDiv.querySelectorAll('button'));
              btns.forEach(b=> b.disabled = true);
              setTimeout(()=>{
                try{
                  const qa = document.getElementById('question-area');
                  const isQuestionVisible = qa ? (window.getComputedStyle(qa).display !== 'none') : false;
                  if(isQuestionVisible && currentPlayer === f.target){
                    btns.forEach(b=> b.disabled = false);
                  }
                }catch(e){}
              }, remaining);
            }
          }
        }
      }catch(e){}
    }

    // Timer com base no timestamp da pergunta
    const startedAt = payload.at || Date.now();
    const elapsed = Math.max(0, Math.floor((Date.now() - startedAt)/1000));
    const remaining = Math.max(0, 15 - elapsed);
  // Guarda contexto da pergunta atual (para timeout e sync)
  try{ window._currentQuestionCtx = { correct, pointsValue, category, by, at: startedAt }; }catch(e){}

  if(localPlayerId === by){
      try{ clearInterval(timer); }catch(e){}
      try{ if(spectatorTimer) { clearInterval(spectatorTimer); spectatorTimer = null; } }catch(e){}
      startTimerRemaining(remaining);
    } else {
      // Exibe contagem restante ao oponente com um timer apenas visual
      try{ if(timer) { clearInterval(timer); } }catch(e){}
      startSpectatorTimerRemaining(remaining);
    }
  }catch(e){ console.warn('renderQuestionPayload error', e); }
}

// Atualiza UI conforme o turno atual
function updateTurnUI(){
  try{
    const qa = document.getElementById('question-area');
    const isQuestionVisible = qa ? (window.getComputedStyle(qa).display !== 'none') : false;
    const ro = document.getElementById('roleta-area');
    if(ro){
      // Se h√° pergunta vis√≠vel, oculta roleta; caso contr√°rio mostra
      if(isQuestionVisible){ ro.style.display = 'none'; } else { ro.style.display = 'flex'; }
    }
    // Ajusta permiss√£o de giro conforme o turno, mantendo roleta vis√≠vel para ambos
    try{
      const iframe = document.getElementById('roletaIframe');
      if(iframe && iframe.contentWindow){
        iframe.contentWindow.postMessage({ type:'setSpinEnabled', enabled: (localPlayerId === currentPlayer) }, '*');
        // Overlay apenas informativo quando n√£o √© minha vez
        const overlay = document.getElementById('roletaOverlay');
        if(overlay) overlay.style.display = (localPlayerId === currentPlayer) ? 'none' : 'flex';
        if(iframe){ if(localPlayerId !== currentPlayer) iframe.classList.add('dim'); else iframe.classList.remove('dim'); }
      }
    }catch(e){}
    const btn = document.getElementById('openRoletaBtn');
    if(btn) btn.disabled = isQuestionVisible || !(localPlayerId === currentPlayer);
    const waiting = document.getElementById('waiting-screen');
    const oppCat = document.getElementById('opponent-category');
    if(isQuestionVisible){
      // N√£o exibir barra inferior durante pergunta
      if(waiting) waiting.style.display = 'none';
      if(oppCat) oppCat.innerText = '';
      try{ setPowerTrayVisible(true); }catch(e){}
    } else {
      if(localPlayerId !== currentPlayer){
        if(waiting) waiting.style.display = 'none';
        if(oppCat) oppCat.innerText = '';
        try{ setPowerTrayVisible(false); }catch(e){}
      } else {
        if(waiting) waiting.style.display = 'none';
        if(oppCat) oppCat.innerText = '';
        try{ setPowerTrayVisible(false); }catch(e){}
      }
    }
  }catch(e){}
}

// Estado inicial: configura UI de turno
document.addEventListener('DOMContentLoaded', ()=>{
  // Limpar estados antigos se necess√°rio e aplicar novo sinal de partida
  try{ maybeClearStaleState(); }catch(e){}
  try{ applyNewMatchSignal(); }catch(e){}
  updateTurnUI();
  try{ hydrateFromStorage(); }catch(e){}
});

(function(){
  const openBtn = document.getElementById('openRoletaBtn');
  const iframe = document.getElementById('roletaIframe');
  const overlay = document.getElementById('roletaOverlay');

  function showModal(){
    try{ iframe.setAttribute('scrolling','no'); iframe.style.overflow = 'hidden'; }catch(e){}
    // Dim/overlay para quem n√£o est√° na vez e bloqueio de intera√ß√£o
    try{
      const isMyTurn = (localPlayerId === currentPlayer);
      if(overlay){ overlay.style.display = isMyTurn ? 'none' : 'flex'; }
      if(iframe){ if(isMyTurn) iframe.classList.remove('dim'); else iframe.classList.add('dim'); }
      // Habilita/desabilita bot√£o Girar dentro da roleta
      try{ iframe.contentWindow.postMessage({ type:'setSpinEnabled', enabled: isMyTurn }, '*'); }catch(e){}
      // Reseta o estado visual interno da roleta (evita mostrar resultado da rodada anterior)
      try{ iframe.contentWindow.postMessage({ type:'resetWheel' }, '*'); }catch(e){}
    }catch(e){}
  }
  function hideModal(){
    try{ if(overlay) overlay.style.display = 'none'; }catch(e){}
    try{ if(iframe) iframe.classList.remove('dim'); }catch(e){}
  }

  if(openBtn){
    openBtn.addEventListener('click', ()=>{
      if (localPlayerId !== currentPlayer) return;
      showModal();
      try{ iframe.src = 'roleta.html?_=' + Date.now(); }catch(e){ console.warn('Failed to set iframe src', e); }
    });
  }

  window.openRoletaModal = function(){
    try{ if(typeof window.ensureRoletaOpenIfIdle === 'function') window.ensureRoletaOpenIfIdle(); }catch(e){ console.warn('openRoletaModal failed', e); }
  };

  window.addEventListener('message', (e)=>{
    try{
      const data = e.data || {};
      // Giro iniciado dentro do iframe (somente na aba do jogador da vez)
      if(data && data.type === 'roletaSpinStarted'){
        if(localPlayerId !== currentPlayer) return; // ignore se n√£o for minha vez
        try{ window._spinInProgress = true; }catch(e){}
        // Esconde as cartas durante o giro da roleta
        try{ const cd = document.getElementById('cards'); if(cd) cd.style.display = 'none'; }catch(e){}
        try{ localStorage.setItem('sync_roleta_spin', JSON.stringify({ index: data.index, turns: data.turns, duration: data.duration, by: currentPlayer, at: Date.now() })); }catch(err){}
        return;
      }
      if(data && data.type === 'roletaResult'){
        try{ window._spinInProgress = false; }catch(e){}
        const category = data.category || '';
        const pointsValue = (typeof data.points === 'number' && data.points > 0) ? data.points : (Math.floor(Math.random()*5) + 1);
        // Mant√©m o resultado vis√≠vel por 3s antes de seguir para a sele√ß√£o de carta
        setTimeout(()=>{
          // Ap√≥s 3s, fecha a roleta e mostra a sele√ß√£o de cartas
          try{ const ro = document.getElementById('roleta-area'); if(ro) ro.style.display = 'none'; }catch(e){}
          try{ const cd = document.getElementById('cards'); if(cd) cd.style.display = 'block'; }catch(e){}
          hideModal();
          const categoryMap = { 'Esportes':'Sports', 'Ci√™ncias':'Science', 'Artes':'Art', 'Mundo':'Movies', 'Sociedade':'History', 'Aleat√≥rio': null };
          const mapped = categoryMap[category] || category;
          const cats = Object.keys(questions);
          const chosen = cats.includes(mapped) ? mapped : (cats[Math.floor(Math.random()*cats.length)]);
          // Sincroniza com a outra aba: resultado da roleta (apenas na aba do jogador da vez)
          if(localPlayerId === currentPlayer){
            try{ localStorage.setItem('sync_roleta', JSON.stringify({ category: chosen, wheelPoints: pointsValue, by: currentPlayer, at: Date.now() })); }catch(e){}
          }
          // Render localmente
          showCardSelection(chosen, pointsValue);
          // Desabilita o bot√£o at√© a pr√≥xima rodada
          try{ const btn = document.getElementById('openRoletaBtn'); if(btn) btn.disabled = true; }catch(e){}
        }, 3000);
      }
    }catch(err){ console.warn('message handler error', err); }
  });

  function showCardSelection(category, wheelPoints){
    // Esconde a roleta durante a sele√ß√£o de cartas
    try{ const ro = document.getElementById('roleta-area'); if(ro) ro.style.display = 'none'; }catch(e){}
    try{ setPowerTrayVisible(false); }catch(e){}
    // Garante ocultar o badge de categoria enquanto escolhe carta
    try{ const badge = document.getElementById('cat-badge'); if(badge){ badge.style.display='none'; badge.textContent=''; } }catch(e){}
    const cardsDiv = document.getElementById('cards');
    cardsDiv.innerHTML = '';
    cardsDiv.style.pointerEvents = 'auto';
  try{ cardsDiv.style.display = 'block'; }catch(e){}
    // Containers para cada lado (mostrados para ambos jogadores)
    const sideLeft = document.createElement('div');
    sideLeft.className = 'cards-side left';
    const sideRight = document.createElement('div');
    sideRight.className = 'cards-side right';
    const stackLeft = document.createElement('div');
    stackLeft.className = 'cards-stack';
    const stackRight = document.createElement('div');
    stackRight.className = 'cards-stack';
    const leftCol = document.createElement('div');
    leftCol.className = 'cards-col';
    const leftCol2 = document.createElement('div');
    leftCol2.className = 'cards-col';
    const rightCol = document.createElement('div');
    rightCol.className = 'cards-col';
    const rightCol2 = document.createElement('div');
    rightCol2.className = 'cards-col';
    stackLeft.appendChild(leftCol);
    stackLeft.appendChild(leftCol2);
    stackRight.appendChild(rightCol);
    stackRight.appendChild(rightCol2);
    sideLeft.appendChild(stackLeft);
    sideRight.appendChild(stackRight);
    cardsDiv.appendChild(sideLeft);
    cardsDiv.appendChild(sideRight);
    // Ajustes de posi√ß√£o solicitados: as 2 cartas internas do lado esquerdo mais para baixo,
    // e no lado direito 3 cartas na borda (coluna externa) e 2 na interna alinhadas ao deslocamento.
    try{
      leftCol2.style.marginTop = '28px'; // desloca as 2 cartas internas do lado esquerdo para baixo
      rightCol.style.marginTop = '28px';  // alinha as 2 cartas internas do lado direito
    }catch(e){}


    // Resetar estado do poder de embaralhar para esta pergunta
    try{ window._shuffleClicks = 0; window._shuffleQAt = payload.at; }catch(e){}
    // Mant√©m o t√≠tulo na posi√ß√£o ANTERIOR (fora do container das cartas)
    try{
      const titleEl = document.getElementById('category');
      if(titleEl){
        titleEl.classList.add('centered-title');
        // Prompt destacado para sele√ß√£o de carta com seta adaptativa
        const arrow = (currentPlayer === 1) ? '‚¨Ö' : '‚û°';
        titleEl.innerText = `Jogador ${currentPlayer}, escolha uma carta  ${arrow}`;
        titleEl.style.fontSize = '28px';
        titleEl.style.fontWeight = '800';
        titleEl.style.letterSpacing = '0.5px';
        titleEl.style.textShadow = '0 0 10px rgba(255,215,0,0.4)';
      }
    }catch(e){}

    let cardChosen = false; // evita dupla sele√ß√£o (manual x autom√°tica)
    let autoPickTimer = null;

    // Valores fixos 1..5; cartas j√° usadas ficam vis√≠veis por√©m desabilitadas (amarelas)
  const myUsed = Array.isArray(usedCardsCache[currentPlayer]) ? usedCardsCache[currentPlayer] : [];
  const values = [1,2,3,4,5];
  const availableValues = values.filter(v => !myUsed.includes(v));
    const cardEls = [];

  // Distribui√ß√£o: valores 1..5 replicados em ambos os lados para visibilidade m√∫tua
    for(let i=0;i<values.length;i++){
      const makeCard = (val, forPlayer)=>{
        const c = document.createElement('div');
        c.className = 'card';
        c.style.position = 'relative';
        c.dataset.value = String(val);
        c.textContent = String(val);
        c.style.fontWeight = '800';
        c.style.color = '#FFFFFF';
        const usedArr = Array.isArray(usedCardsCache[forPlayer]) ? usedCardsCache[forPlayer] : [];
        if(usedArr.includes(val)) c.classList.add('card-used');
    if(usedArr.includes(val)) c.style.color = '#000';
        return c;
      };
      const val = values[i];
  const cardLeft = makeCard(val,1);
  const cardRight = makeCard(val,2);
  // Lado esquerdo: 3 na borda (coluna externa = primeira), 2 na coluna interna (deslocada)
  if(i < 3){ leftCol.appendChild(cardLeft); }
  else { leftCol2.appendChild(cardLeft); }
  // Lado direito: 3 na borda (coluna externa = segunda), 2 na coluna interna (primeira)
  if(i < 3){ rightCol2.appendChild(cardRight); }
  else { rightCol.appendChild(cardRight); }
      // Intera√ß√£o s√≥ em um conjunto (lado dependente do jogador local)
      const interactiveCard = (localPlayerId === 2) ? cardRight : cardLeft;
      cardEls.push(interactiveCard);
    }

    // Se nenhuma carta restar dispon√≠vel, segue direto usando o wheelPoints para n√£o travar a rodada
    if(availableValues.length === 0){
      try{
        const payload = { category: category, pointsValue: wheelPoints || 1, by: currentPlayer, at: Date.now(), noCardAvailable: true };
        localStorage.setItem('sync_card', JSON.stringify(payload));
      }catch(e){}
      setTimeout(()=> chooseCard(wheelPoints || 1, category), 300);
      return;
    }

    // Habilitar clique
    cardsDiv.addEventListener('click', function onCardsClick(e){
      const card = e.target.closest('.card');
      if(!card) return;
      if (localPlayerId !== currentPlayer) return; // s√≥ quem est√° na vez pode escolher
      if(card.classList.contains('card-used')) return; // carta j√° usada n√£o pode ser selecionada
      if(cardChosen) return;
      cardChosen = true;
      try{ if(autoPickTimer){ clearTimeout(autoPickTimer); autoPickTimer = null; } }catch(e){}

      const cardValue = parseInt(card.dataset.value,10);
      const pts = cardValue || wheelPoints || 1;
      // Marca visual imediata (amarelo) no lado do jogador local
  try{ card.classList.add('card-used'); card.style.color = '#000'; }catch(e){}
      // Marca local e persiste como usada
      try{
        const arr = Array.isArray(usedCardsCache[currentPlayer]) ? usedCardsCache[currentPlayer] : [];
        if(!arr.includes(cardValue)) arr.push(cardValue);
        usedCardsCache[currentPlayer] = arr;
        localStorage.setItem('used_cards_'+currentPlayer, JSON.stringify(arr));
      }catch(e){}
      try{ localStorage.setItem('sync_card', JSON.stringify({ category: category, pointsValue: pts, by: currentPlayer, at: Date.now(), cardValue: cardValue })); }catch(e){}
      // mant√©m cartas na tela, mas desabilita clicks
      cardsDiv.style.pointerEvents = 'none';
      cardsDiv.removeEventListener('click', onCardsClick);
      chooseCard(pts, category);
    });

    // Sele√ß√£o autom√°tica ap√≥s 5s se o jogador da vez n√£o escolher
    if(localPlayerId === currentPlayer){
      autoPickTimer = setTimeout(()=>{
        try{
          if(cardChosen) return;
          const available = cardEls.filter(el => !el.classList.contains('card-used'));
          if(available.length === 0){
            // fallback: n√£o h√° cartas, segue direto pelo valor da roleta
            const pts = wheelPoints || 1;
            try{ localStorage.setItem('sync_card', JSON.stringify({ category: category, pointsValue: pts, by: currentPlayer, at: Date.now(), noCardAvailable: true })); }catch(e){}
            chooseCard(pts, category);
            return;
          }
          const picked = available[Math.floor(Math.random()*available.length)];
          cardChosen = true;
          const cardValue = parseInt(picked.dataset.value,10);
          const pts = cardValue || wheelPoints || 1;
          try{
            const arr = Array.isArray(usedCardsCache[currentPlayer]) ? usedCardsCache[currentPlayer] : [];
            if(!arr.includes(cardValue)) arr.push(cardValue);
            usedCardsCache[currentPlayer] = arr;
            localStorage.setItem('used_cards_'+currentPlayer, JSON.stringify(arr));
          }catch(e){}
          // Marca visual imediata tamb√©m na sele√ß√£o autom√°tica
          try{ picked.classList.add('card-used'); picked.style.color = '#000'; }catch(e){}
          try{ localStorage.setItem('sync_card', JSON.stringify({ category: category, pointsValue: pts, by: currentPlayer, at: Date.now(), cardValue: cardValue })); }catch(e){}
          // mant√©m cartas na tela, mas desabilita clicks
          cardsDiv.style.pointerEvents = 'none';
          chooseCard(pts, category);
        }catch(e){}
      }, 5000);
    }
  }

  // Torna a fun√ß√£o dispon√≠vel globalmente para outras partes do script (ex.: listeners fora deste bloco)
  try{ window.showCardSelection = showCardSelection; }catch(e){}

  // Garante abrir a roleta automaticamente quando for a hora de girar
  function ensureRoletaOpenIfIdle(){
    try{
      const qa = document.getElementById('question-area');
      const cards = document.getElementById('cards');
      const isQ = qa && window.getComputedStyle(qa).display !== 'none';
      const isC = cards && window.getComputedStyle(cards).display !== 'none';
      if(!isQ && !isC){
        // For√ßa recarregar o iframe a cada rodada para limpar estado interno
        try{ iframe.src = 'roleta.html?_=' + Date.now(); }catch(e){}
        // Configura roleta para ambas as telas sem modal (exposta inline)
        showModal();
        // Habilita/desabilita o bot√£o girar conforme o turno ap√≥s o load
        const sendSetup = ()=>{
          try{ iframe.contentWindow.postMessage({ type:'setSpinEnabled', enabled: (localPlayerId === currentPlayer) }, '*'); }catch(e){}
          try{ iframe.contentWindow.postMessage({ type:'resetWheel' }, '*'); }catch(e){}
        };
        try{
          if(!iframe.contentWindow || iframe.contentDocument.readyState !== 'complete'){
            iframe.addEventListener('load', function onld(){ try{ sendSetup(); }catch(e){} iframe.removeEventListener('load', onld); });
          } else {
            sendSetup();
          }
        }catch(e){}
      }
    }catch(e){}
  }
  try{ window.ensureRoletaOpenIfIdle = ensureRoletaOpenIfIdle; }catch(e){}

  // Garante que a roleta esteja pronta para um novo giro (sem recarregar iframe)
  function setupRoletaForTurn(){
    try{
      const iframe = document.getElementById('roletaIframe');
      if(!iframe) return;
      // Garante visibilidade da roleta quando n√£o h√° pergunta
      try{
        const qa = document.getElementById('question-area');
        const ro = document.getElementById('roleta-area');
        const isQuestionVisible = qa ? (window.getComputedStyle(qa).display !== 'none') : false;
        if(ro && !isQuestionVisible){ ro.style.display = 'flex'; }
      }catch(e){}

      // Recarrega o iframe a cada novo turno para evitar estados travados
      try{ iframe.src = 'roleta.html?_=' + Date.now(); }catch(e){}

      const sendSetup = ()=>{
        try{ iframe.contentWindow.postMessage({ type:'setSpinEnabled', enabled: (localPlayerId === currentPlayer) }, '*'); }catch(e){}
        try{ iframe.contentWindow.postMessage({ type:'resetWheel' }, '*'); }catch(e){}
        // Ajusta overlay/dim coerente com a vez
        try{
          const overlay = document.getElementById('roletaOverlay');
          if(overlay) overlay.style.display = (localPlayerId === currentPlayer) ? 'none' : 'flex';
          if(iframe){ if(localPlayerId !== currentPlayer) iframe.classList.add('dim'); else iframe.classList.remove('dim'); }
        }catch(e){}
      };
      if(!iframe.contentWindow || (iframe.contentDocument && iframe.contentDocument.readyState !== 'complete')){
        iframe.addEventListener('load', function onld(){ try{ sendSetup(); }catch(e){} iframe.removeEventListener('load', onld); });
      } else {
        sendSetup();
      }
    }catch(e){}
  }
  try{ window.setupRoletaForTurn = setupRoletaForTurn; }catch(e){}
})();

// Hidrata a tela atual com base no √∫ltimo evento salvo no localStorage
function hydrateFromStorage(){
  try{
    const parse = (k)=>{ try{ return JSON.parse(localStorage.getItem(k)||'{}'); }catch(e){ return null; } };
    const q = parse('sync_question');
    const a = parse('sync_answer');
    const r = parse('sync_roleta');
    const s = parse('sync_roleta_spin');
    const m = parse('matchResult');
    // Hidratar cartas usadas separadas por jogador
    const uc1 = (()=>{ try{ return JSON.parse(localStorage.getItem('used_cards_1')||'[]'); }catch(e){ return []; } })();
    const uc2 = (()=>{ try{ return JSON.parse(localStorage.getItem('used_cards_2')||'[]'); }catch(e){ return []; } })();
    usedCardsCache = { 1: Array.isArray(uc1) ? uc1 : [], 2: Array.isArray(uc2) ? uc2 : [] };
    const getAt = (o)=> (o && typeof o.at === 'number') ? o.at : 0;
    const latest = [q,a,r,s,m].filter(Boolean).sort((x,y)=> getAt(y)-getAt(x))[0] || null;

    // Pontos: se houver sync_answer, aplique a pontua√ß√£o mais recente
    if(a && a.newPoints){
      points[1] = a.newPoints[1]||0; points[2] = a.newPoints[2]||0;
      const p1El = document.getElementById('player1-points'); if(p1El) p1El.textContent = `${points[1]} pts`;
      const p2El = document.getElementById('player2-points'); if(p2El) p2El.textContent = `${points[2]} pts`;
    }

    if(latest === m && m && m.winnerId){
      // Se a partida j√° terminou, mostra o estado final apropriado
      const winner = { id: m.winnerId, name: document.getElementById(`player${m.winnerId}-name`).textContent, pts: m.pts };
      if(localPlayerId === m.winnerId){
        showFinalWinner(winner);
      } else if(localPlayerId === (m.winnerId === 1 ? 2 : 1)){
        showLoserModal(m);
      }
      return;
    }

    if(latest === q && q && q.category){
      // Estamos no meio de uma pergunta
      currentPlayer = q.by || currentPlayer;
      renderQuestionPayload(q);
      updateTurnUI();
      return;
    }

    if(latest === r && r && r.category){
      // Sele√ß√£o de cartas em andamento
      currentPlayer = r.by || currentPlayer;
      // N√£o ocultar roleta durante sele√ß√£o
      try{ setPowerTrayVisible(false); }catch(e){}
      showCardSelection(r.category, r.wheelPoints || 1);
      updateTurnUI();
      return;
    }

    if(latest === s && s && typeof s.index === 'number'){
      // Giro da roleta em andamento: abrir modal e sincronizar giro
      currentPlayer = s.by || currentPlayer;
      try{
        try{ window._spinInProgress = true; }catch(e){}
        try{ if(typeof window.ensureRoletaOpenIfIdle === 'function') window.ensureRoletaOpenIfIdle(); }catch(e){}
        const iframe = document.getElementById('roletaIframe');
        // aplica overlay se n√£o for minha vez
        try{
          const overlay = document.getElementById('roletaOverlay');
          if(overlay) overlay.style.display = (localPlayerId === currentPlayer) ? 'none' : 'flex';
          if(iframe){ if(localPlayerId !== currentPlayer) iframe.classList.add('dim'); else iframe.classList.remove('dim'); }
        }catch(e){}
        // dispara o giro (pode ocorrer pequeno atraso)
        try{ iframe.contentWindow.postMessage({ type:'spinNow', index: s.index, turns: s.turns, duration: s.duration }, '*'); }catch(e){}
      }catch(e){}
      updateTurnUI();
      try{ setPowerTrayVisible(false); }catch(e){}
      return;
    }

    if(a && a.nextPlayer){
      // Ap√≥s resposta, define pr√≥ximo jogador
      currentPlayer = a.nextPlayer;
      updateTurnUI();
      return;
    }

    // Estado inicial padr√£o: Jogador 1 abre a roleta
    currentPlayer = 1;
    updateTurnUI();
    try{ if(typeof window.ensureRoletaOpenIfIdle === 'function') window.ensureRoletaOpenIfIdle(); }catch(e){}
  }catch(e){ console.warn('hydrateFromStorage error', e); }
}

// Sincroniza√ß√£o entre telas: ou√ßa vencedor e rematch via localStorage
try{
  window.addEventListener('storage', (ev) => {
    if(!ev) return;
    if(ev.key === 'matchResult'){
      try{
        const data = JSON.parse(ev.newValue||'{}');
        if(data && data.winnerId && data.loserId){
          if(localPlayerId === data.loserId){
            // Mostra modal de derrota sem anima√ß√µes
            showLoserModal(data);
          }
        }
      }catch(e){}
    }
    if(ev.key === 'rematchNow'){
      // Reinicia ambas as telas
      try{ stopConfettiLoop(); }catch(e){}
      try{ stopFireworksLoop(); }catch(e){}
      try{ clearRematchTimeout(); }catch(e){}
      try{ localStorage.removeItem('used_cards_1'); localStorage.removeItem('used_cards_2'); localStorage.removeItem('used_cards'); }catch(e){}
      location.reload();
    }
    if(ev.key === 'rematchRequest'){
      try{
        const data = JSON.parse(ev.newValue||'{}');
        if(!data || !data.from) return;
        // Se eu solicitei, mostra aguardando; se fui solicitado, mostra prompt
        if(localPlayerId === data.from){
          const oppId = (data.to) ? data.to : (localPlayerId === 1 ? 2 : 1);
          showRematchWaitingModal(oppId);
          try{ startRematchTimeout(); }catch(e){}
        } else if(localPlayerId === (data.to || (localPlayerId === 1 ? 2 : 1))){
          showRematchPromptModal(data.from);
          try{ startRematchTimeout(); }catch(e){}
        }
      }catch(e){}
    }
    if(ev.key === 'rematchResponse'){
      try{
        const data = JSON.parse(ev.newValue||'{}');
        if(!data) return;
        hideRematchModals();
        try{ clearRematchTimeout(); }catch(e){}
        if(data.accepted){
          try{ localStorage.setItem('rematchNow', String(Date.now())); }catch(e){}
        } else {
          try{ localStorage.setItem('goLobbyNow', String(Date.now())); }catch(e){}
        }
      }catch(e){}
    }
    if(ev.key === 'goLobbyNow'){
      // Volta ao lobby em ambas as telas
      try{ stopConfettiLoop(); }catch(e){}
      try{ stopFireworksLoop(); }catch(e){}
      try{ clearRematchTimeout(); }catch(e){}
      try{ localStorage.removeItem('used_cards_1'); localStorage.removeItem('used_cards_2'); localStorage.removeItem('used_cards'); }catch(e){}
      location.href = 'players.html';
    }
    // Giro iniciado na outra aba: sincroniza o giro nesta
    if(ev.key === 'sync_roleta_spin'){
      try{
        const data = JSON.parse(ev.newValue||'{}');
        if(!data || typeof data.index !== 'number') return;
        // Abre a roleta e mostra overlay conforme o turno
        try{ window._spinInProgress = true; }catch(e){}
        try{ if(typeof window.ensureRoletaOpenIfIdle === 'function') window.ensureRoletaOpenIfIdle(); }catch(e){}
        // Esconde as cartas durante o giro da roleta
        try{ const cd = document.getElementById('cards'); if(cd) cd.style.display = 'none'; }catch(e){}
        const iframe = document.getElementById('roletaIframe');
        // Como n√£o √© a nossa vez, garante overlay e desabilita o bot√£o
        try{
          const overlay = document.getElementById('roletaOverlay');
          if(overlay) overlay.style.display = (localPlayerId === currentPlayer) ? 'none' : 'flex';
          if(iframe){ if(localPlayerId !== currentPlayer) iframe.classList.add('dim'); }
        }catch(e){}
        // Dispara o giro com os mesmos par√¢metros (aguarda iframe pronto, se necess√°rio)
        const postSpin = ()=>{ try{ iframe.contentWindow.postMessage({ type:'spinNow', index: data.index, turns: data.turns, duration: data.duration }, '*'); }catch(e){} };
        try{
          if(!iframe.contentWindow || iframe.contentDocument.readyState !== 'complete'){
            iframe.addEventListener('load', function onld(){ try{ postSpin(); }catch(e){} iframe.removeEventListener('load', onld); });
          } else {
            postSpin();
          }
        }catch(e){}
      }catch(e){}
    }
    // Resultado da roleta vindo da outra aba
    if(ev.key === 'sync_roleta'){
      try{
        const data = JSON.parse(ev.newValue||'{}');
        if(!data || !data.category) return;
        try{ window._spinInProgress = false; }catch(e){}
        // Mant√©m resultado vis√≠vel por 3s antes de fechar a roleta e mostrar cartas
        setTimeout(()=>{
          try{ const ro = document.getElementById('roleta-area'); if(ro) ro.style.display = 'none'; }catch(e){}
          try{ const cd = document.getElementById('cards'); if(cd) cd.style.display = 'block'; }catch(e){}
          try{ setPowerTrayVisible(false); }catch(e){}
          showCardSelection(data.category, data.wheelPoints || 1);
        }, 3000);
      }catch(e){}
    }
    // Sele√ß√£o de carta confirmada na outra aba
    if(ev.key === 'sync_card'){
      try{
        const data = JSON.parse(ev.newValue||'{}');
        if(!data || !data.category) return;
        // Desabilita intera√ß√£o local das cartas, mas mant√©m vis√≠veis
        try{ const cd = document.getElementById('cards'); if(cd) cd.style.pointerEvents = 'none'; }catch(e){}
        // Marca a carta como usada tamb√©m neste cliente, atualiza cache e visual
        try{
          const cardValue = (typeof data.cardValue === 'number') ? data.cardValue : (typeof data.pointsValue === 'number' ? data.pointsValue : null);
          const by = data.by;
          // s√≥ marca se valor v√°lido 1..5 e n√£o for um avan√ßo sem carta
          if(by === 1 || by === 2){
            if(cardValue != null && cardValue >= 1 && cardValue <= 5 && !data.noCardAvailable){
              const arr = Array.isArray(usedCardsCache[by]) ? usedCardsCache[by] : [];
              if(!arr.includes(cardValue)){
                arr.push(cardValue);
                usedCardsCache[by] = arr;
                localStorage.setItem('used_cards_'+by, JSON.stringify(arr));
              }
              const root = document.getElementById('cards');
              if(root){
                const sideSel = (by === 1) ? '.cards-side.left' : '.cards-side.right';
                const sideRoot = root.querySelector(sideSel);
                if(sideRoot){
                  const el = sideRoot.querySelector(`.card[data-value="${cardValue}"]`);
                  if(el) el.classList.add('card-used');
                  if(el) el.style.color = '#000';
                }
              }
            }
          }
        }catch(e){}
        // Aguardamos 'sync_question' para renderizar a pergunta
      }catch(e){}
    }
    // NOVO: mesma pergunta para ambas telas
    if(ev.key === 'sync_question'){
      try{
        const data = JSON.parse(ev.newValue||'{}');
        if(!data || !data.category) return;
        renderQuestionPayload(data);
        updateTurnUI();
      }catch(e){}
    }
    // Resposta confirmada na outra aba
    if(ev.key === 'sync_answer'){
      try{
        const data = JSON.parse(ev.newValue||'{}');
        if(!data) return;
        // Destaca alternativas por 2s no lado do oponente tamb√©m
        try{
          const ansDiv = document.getElementById('answers');
          if(ansDiv){
            const btns = Array.from(ansDiv.querySelectorAll('button'));
            btns.forEach(b=> b.disabled = true);
            if(data.selectedIndex != null){
              const selBtn = ansDiv.querySelector(`button[data-idx="${data.selectedIndex}"]`);
              if(selBtn){ selBtn.classList.add(data.correct ? 'ans-correct' : 'ans-wrong'); }
            }
            if(!data.correct && data.correctIndex != null){
              const corBtn = ansDiv.querySelector(`button[data-idx="${data.correctIndex}"]`);
              if(corBtn){ corBtn.classList.add('ans-correct'); }
            }
            if(data.selectedIndex == null && data.correctIndex != null){
              const corBtn = ansDiv.querySelector(`button[data-idx="${data.correctIndex}"]`);
              if(corBtn){ corBtn.classList.add('ans-correct'); }
            }
          }
        }catch(e){}
        // Ap√≥s 2s aplica pontos e segue fluxo
        setTimeout(()=>{
          try{
            if(data.newPoints){
              points[1] = data.newPoints[1]||0; points[2] = data.newPoints[2]||0;
              const p1El = document.getElementById('player1-points'); if(p1El) p1El.textContent = `${points[1]} pts`;
              const p2El = document.getElementById('player2-points'); if(p2El) p2El.textContent = `${points[2]} pts`;
            }
            if(checkForWinner()) return;
            try{ if(spectatorTimer){ clearInterval(spectatorTimer); spectatorTimer = null; } }catch(e){}
            try{ document.getElementById('question-area').style.display = 'none'; }catch(e){}
            try{ document.getElementById('category').innerText = ''; }catch(e){}
            try{ document.getElementById('waiting-screen').style.display = 'none'; }catch(e){}
            try{ setPowerTrayVisible(false); }catch(e){}
            currentPlayer = data.nextPlayer || (currentPlayer===1?2:1);
            try{ const ro = document.getElementById('roleta-area'); if(ro) ro.style.display = 'none'; }catch(e){}
            updateTurnUI();
            if(typeof window.ensureRoletaOpenIfIdle === 'function') window.ensureRoletaOpenIfIdle();
            if(typeof window.setupRoletaForTurn === 'function') window.setupRoletaForTurn();
          }catch(e){}
        }, 2000);
      }catch(e){}
    }
    if(ev.key === 'power_freeze'){
      try{
        const data = JSON.parse(ev.newValue||'{}');
        if(!data || typeof data.target !== 'number') return;
        // Aplica somente na aba do jogador alvo (currentPlayer === target)
        if(currentPlayer === data.target){
          // Desabilita respostas por 5s
          const ansDiv = document.getElementById('answers');
          if(ansDiv){
            const btns = Array.from(ansDiv.querySelectorAll('button'));
            btns.forEach(b=> b.disabled = true);
            setTimeout(()=>{
              try{
                // Reabilita apenas se a pergunta ainda est√° ativa e ainda √© a vez deste jogador
                const qa = document.getElementById('question-area');
                const isQuestionVisible = qa ? (window.getComputedStyle(qa).display !== 'none') : false;
                if(isQuestionVisible && currentPlayer === data.target){
                  btns.forEach(b=> b.disabled = false);
                }
              }catch(e){}
            }, data.durationMs || 5000);
          }
        }
      }catch(e){}
    }
    if(ev.key === 'power_shuffle'){
      try{
        const data = JSON.parse(ev.newValue||'{}');
        if(!data || typeof data.target !== 'number') return;
        // Aplica somente na aba do jogador alvo (quem responde) e na mesma pergunta
        const ctx = window._currentQuestionCtx || {};
        if(currentPlayer === data.target && ctx && ctx.at && ctx.at === data.qAt){
          // Limita a 3 embaralhamentos; no 4¬∫ click (evento extra) ignora para deixar responder
          window._shuffleClicks = (window._shuffleClicks||0) + 1;
          if(window._shuffleClicks > 3) return; // j√° atingiu limite de embaralhes
          const ansDiv = document.getElementById('answers');
          if(ansDiv){
            const btns = Array.from(ansDiv.querySelectorAll('button'));
            if(btns.length > 1){
              // Captura texto da correta atual
              const correctIndex = typeof ctx.correct === 'number' ? ctx.correct : null;
              if(correctIndex != null && correctIndex >=0 && correctIndex < btns.length){
                // Embaralhar: escolher posi√ß√£o nova diferente
                let newPos;
                do{ newPos = Math.floor(Math.random()*btns.length); }while(newPos === correctIndex);
                if(newPos !== correctIndex){
                  // Swap visual: trocar apenas os textos para n√£o perder handlers
                  const tmp = btns[newPos].innerText;
                  btns[newPos].innerText = btns[correctIndex].innerText;
                  btns[correctIndex].innerText = tmp;
                  // Atualiza √≠ndice correto interno
                  ctx.correct = newPos;
                  try{ window._currentQuestionCtx.correct = newPos; }catch(e){}
                }
              }
            }
          }
        }
      }catch(e){}
    }
  });
}catch(e){ /* ignore */ }

function chooseCard(pointsValue, category) {
  // Mant√©m a roleta vis√≠vel sempre
  try{ document.getElementById('openRoletaBtn').disabled = true; }catch(e){}
  // Limpa qualquer t√≠tulo anterior e waiting-screen
  try{ const catEl = document.getElementById('category'); if(catEl) { catEl.classList.remove('centered-title'); catEl.innerText = ''; } }catch(e){}
  try{ const badge = document.getElementById('cat-badge'); if(badge){ badge.style.display='none'; badge.textContent=''; } }catch(e){}
  try{ const ws = document.getElementById('waiting-screen'); if(ws) ws.style.display = 'none'; }catch(e){}

  const qData = questions[category][0];
  const payload = {
    category,
    question: qData.question,
    answers: qData.answers,
    correct: qData.correct,
    pointsValue: pointsValue,
    by: currentPlayer,
    at: Date.now()
  };

  // Envia a pergunta para a outra tela e renderiza localmente para ambos
  try{ localStorage.setItem('sync_question', JSON.stringify(payload)); }catch(e){}
  renderQuestionPayload(payload);
}

function startTimer() {
  clearInterval(timer);
  try{ if(spectatorTimer){ clearInterval(spectatorTimer); spectatorTimer = null; } }catch(e){}
  timeLeft = 15;
  updateTimer();
  timer = setInterval(() => {
    timeLeft--;
    updateTimer();
    if (timeLeft <= 0) {
      clearInterval(timer);
      try{
        const ctx = window._currentQuestionCtx || {};
        answerQuestion(false, ctx.pointsValue||0, ctx.category||'', null, typeof ctx.correct==='number'?ctx.correct:null);
      }catch(e){ answerQuestion(false); }
    }
  }, 1000);
}

// Inicia o timer com tempo restante espec√≠fico (para sincronizar entre abas)
function startTimerRemaining(remaining) {
  clearInterval(timer);
  try{ if(spectatorTimer){ clearInterval(spectatorTimer); spectatorTimer = null; } }catch(e){}
  timeLeft = Math.max(0, Math.floor(remaining || 0));
  updateTimer();
  if (timeLeft <= 0) {
    try{
      const ctx = window._currentQuestionCtx || {};
      answerQuestion(false, ctx.pointsValue||0, ctx.category||'', null, typeof ctx.correct==='number'?ctx.correct:null);
    }catch(e){ answerQuestion(false); }
    return;
  }
  try{ setPowerTrayVisible(true); }catch(e){}
  timer = setInterval(() => {
    timeLeft--;
    updateTimer();
    if (timeLeft <= 0) {
      clearInterval(timer);
      try{
        const ctx = window._currentQuestionCtx || {};
        answerQuestion(false, ctx.pointsValue||0, ctx.category||'', null, typeof ctx.correct==='number'?ctx.correct:null);
      }catch(e){ answerQuestion(false); }
    }
  }, 1000);
}

// Timer apenas visual para o oponente acompanhar a contagem regressiva
function startSpectatorTimerRemaining(remaining){
  try{ if(spectatorTimer){ clearInterval(spectatorTimer); } }catch(e){}
  try{ if(timer){ clearInterval(timer); } }catch(e){}
  timeLeft = Math.max(0, Math.floor(remaining || 0));
  updateTimer();
  if(timeLeft <= 0){ return; }
  spectatorTimer = setInterval(()=>{
    timeLeft--;
    updateTimer();
    if(timeLeft <= 0){
      try{ clearInterval(spectatorTimer); spectatorTimer = null; }catch(e){}
    }
  }, 1000);
}

function updateTimer() {
  document.getElementById("timer-text").innerText = timeLeft;
  const circle = document.getElementById("timer-circle");
  const offset = (15 - timeLeft) * (170 / 15);
  circle.style.strokeDashoffset = offset;
  circle.style.stroke = timeLeft > 5 ? "#00FF00" : "#FF0000";
}

function answerQuestion(isCorrect, pointsValue = 0, category = "", selectedIndex = null, correctIndex = null) {
  clearInterval(timer);
  try{ if(spectatorTimer){ clearInterval(spectatorTimer); spectatorTimer = null; } }catch(e){}

  // Destacar alternativas por 2s
  try{
    const ansDiv = document.getElementById('answers');
    if(ansDiv){
      const btns = Array.from(ansDiv.querySelectorAll('button'));
      btns.forEach(b=>{ b.disabled = true; });
      if(selectedIndex != null){
        const selBtn = ansDiv.querySelector(`button[data-idx="${selectedIndex}"]`);
        if(selBtn){ selBtn.classList.add(isCorrect ? 'ans-correct' : 'ans-wrong'); }
      }
      if(!isCorrect && correctIndex != null){
        const corBtn = ansDiv.querySelector(`button[data-idx="${correctIndex}"]`);
        if(corBtn){ corBtn.classList.add('ans-correct'); }
      }
      // Se tempo acabou e ningu√©m escolheu, ainda destacamos a correta
      if(selectedIndex == null && correctIndex != null){
        const corBtn = ansDiv.querySelector(`button[data-idx="${correctIndex}"]`);
        if(corBtn){ corBtn.classList.add('ans-correct'); }
      }
    }
  }catch(e){}

  // Calcula pontua√ß√£o resultante e pr√≥ximo jogador
  const next = (currentPlayer === 1) ? 2 : 1;
  const newPoints = { 1: points[1], 2: points[2] };
  if(isCorrect){ newPoints[currentPlayer] += pointsValue; }

  // Envia sync imediatamente para oponente aplicar destaque tamb√©m
  try{
    localStorage.setItem('sync_answer', JSON.stringify({ by: currentPlayer, correct: isCorrect, pointsValue, category, newPoints, nextPlayer: next, at: Date.now(), selectedIndex, correctIndex }));
  }catch(e){}

  // Ap√≥s 2s (tempo do destaque), aplica efeitos e segue o jogo
  setTimeout(()=>{
    // aplica pontos localmente
    points = newPoints;
    try{ document.getElementById(`player1-points`).innerText = `${points[1]} pts`; }catch(e){}
    try{ document.getElementById(`player2-points`).innerText = `${points[2]} pts`; }catch(e){}

    // Checa vencedor ap√≥s aplicar pontua√ß√£o
    // Incrementa rodada e verifica limite ou vencedor
    roundCount += 1;
    if(checkForWinner()) return;
    finalizeIfRoundLimitOrWinner();
    if(roundCount >= 5) return; // j√° finalizado

    // Esconde pergunta e limpa UI
    try{ document.getElementById("question-area").style.display = "none"; }catch(e){}
    try{ document.getElementById("category").innerText = ""; }catch(e){}
    try{ const badge = document.getElementById('cat-badge'); if(badge){ badge.style.display='none'; badge.textContent=''; } }catch(e){}
    try{ setPowerTrayVisible(false); }catch(e){}

    currentPlayer = next;
    // Prepara pr√≥xima roleta imediatamente (o delay j√° foi o destaque de 2s)
    try{ const ro = document.getElementById('roleta-area'); if(ro) ro.style.display = 'none'; }catch(e){}
    try{
      updateTurnUI();
      if(typeof window.ensureRoletaOpenIfIdle === 'function') window.ensureRoletaOpenIfIdle();
      if(typeof window.setupRoletaForTurn === 'function') window.setupRoletaForTurn();
    }catch(e){}
  }, 2000);
}

// Controle simples da visibilidade da barra de poderes (apenas est√©tica por enquanto)
function setPowerTrayVisible(show){
  try{
    const tray = document.getElementById('power-tray');
    if(!tray) return;
    // Exibe poderes do oponente em todas as perguntas (sempre que show=true e pergunta vis√≠vel)
    const qa = document.getElementById('question-area');
    const isQuestionVisible = qa ? (window.getComputedStyle(qa).display !== 'none') : false;
    tray.style.display = (show && isQuestionVisible) ? 'flex' : 'none';
    // Ajusta posi√ß√£o para jogador 2 (lado direito) ou jogador 1 (centro)
    if(show){
      // Limpa classes anteriores de posicionamento
      tray.classList.remove('center');
      tray.classList.remove('right');
      tray.classList.remove('left');
      if(localPlayerId === 2){
        tray.classList.add('right');
      } else {
        // Jogador 1: poderes no canto inferior esquerdo
        tray.classList.add('left');
      }
      // Esconde poderes (local-only) no oponente: apenas o jogador da vez v√™ os 5 poderes na sua aba
      try{
        // Durante a pergunta: o jogador da vez N√ÉO v√™; o oponente v√™ todos
        const isOpponentView = (localPlayerId !== currentPlayer);
        const showLocalPowers = isQuestionVisible && isOpponentView;
        const localOnlyButtons = tray.querySelectorAll('.power-btn.local-only');
        localOnlyButtons.forEach(btn=>{
          if(showLocalPowers){ btn.classList.remove('hidden-remote'); }
          else { btn.classList.add('hidden-remote'); }
        });
      }catch(e){}
    }
  }catch(e){}
}

function opponentTurn() {
  const categories = Object.keys(questions);
  const category = categories[Math.floor(Math.random() * categories.length)];
  document.getElementById("opponent-category").innerText = `Categoria do oponente: ${englishToPt(category)}`;
  startTimer();

  setTimeout(() => {
    clearInterval(timer);
    const correct = Math.random() > 0.4;
    const earned = Math.floor(Math.random() * 5) + 1;
    if (correct) points[2] += earned;
    document.getElementById("player2-points").innerText = `${points[2]} pts`;
    if(checkForWinner()) return;
            // Incrementa rodada e verifica vencedor / limite
            roundCount += 1;
            if(checkForWinner()) return;
            finalizeIfRoundLimitOrWinner();
            if(roundCount >= 5) return; // finalizou
    document.getElementById("waiting-screen").style.display = "none";
    document.getElementById("opponent-category").innerText = "";
    document.getElementById("roleta-area").style.display = "flex";
    try{ document.getElementById('openRoletaBtn').disabled = false; }catch(e){}
    try{
      setTimeout(() => {
        if (typeof window.openRoletaModal === 'function') window.openRoletaModal();
        else document.getElementById('openRoletaBtn').click();
      }, 800);
    }catch(err){ console.warn('auto-open roleta failed', err); }
  }, 4000);
}

function checkForWinner(){
  const winScore = 15;
  if(points[1] >= winScore || points[2] >= winScore){
    const winner = points[1] >= winScore ? {id:1,name:document.getElementById('player1-name').textContent,pts:points[1]} : {id:2,name:document.getElementById('player2-name').textContent,pts:points[2]};
    showFinalWinner(winner);
    return true;
  }
  return false;
}

function showFinalWinner(winner){
  clearInterval(timer);
  try{ if(spectatorTimer){ clearInterval(spectatorTimer); spectatorTimer = null; } }catch(e){}
  document.getElementById('roleta-area').style.display = 'none';
  document.getElementById('question-area').style.display = 'none';
  document.getElementById('cards').style.display = 'none';
  document.getElementById('waiting-screen').style.display = 'none';
  try{ setPowerTrayVisible(false); }catch(e){}

  let modal = document.getElementById('finalWinnerModal');
  if(!modal){
    modal = document.createElement('div');
    modal.id = 'finalWinnerModal';
    modal.style.position = 'fixed';
    modal.style.inset = '0';
    modal.style.display = 'flex';
    modal.style.alignItems = 'center';
    modal.style.justifyContent = 'center';
    modal.style.background = 'rgba(0,0,0,0.65)';
    modal.style.zIndex = 10000;
    modal.innerHTML = `
      <div class="fw-modal-content">
        <img id="fw-icon" class="fw-modal-icon" src="" alt="√çcone do vencedor">
        <div style="text-align:left;min-width:0">
          <h2 style="margin:0 0 8px 0">Fim da Partida</h2>
          <p style="font-size:18px;margin:8px 0">Vencedor: <strong id=fw-name></strong></p>
          <p style="margin:8px 0">Pontos: <strong id=fw-pts></strong></p>
          <div style="margin-top:12px;display:flex;gap:8px;justify-content:flex-start;flex-wrap:wrap;">
            <button id="fw-restart" style="padding:8px 12px;border-radius:8px;border:none;background:#1a4cd7;color:#fff;cursor:pointer">Reiniciar</button>
            <button id="fw-lobby" style="padding:8px 12px;border-radius:8px;border:none;background:#5cb85c;color:#fff;cursor:pointer">Voltar ao Lobby</button>
          </div>
        </div>
      </div>`;
    document.body.appendChild(modal);
    // set icon src from the corresponding player icon if available
    try{
      const fwIconEl = document.getElementById('fw-icon');
      const srcEl = document.getElementById(`player${winner.id}-icon`);
      if(fwIconEl && srcEl && srcEl.src) fwIconEl.src = srcEl.src;
    }catch(e){}
  document.getElementById('fw-restart').addEventListener('click', ()=> {
    try{
      const loserId = (winner && winner.id === 1) ? 2 : 1;
      const payload = { from: localPlayerId, to: loserId, at: Date.now() };
      localStorage.setItem('rematchRequest', JSON.stringify(payload));
      // mostra "aguardando oponente" enquanto espera a resposta
      showRematchWaitingModal(loserId);
      try{ startRematchTimeout(); }catch(e){}
    }catch(e){}
    try{ stopConfettiLoop(); }catch(e){}; try{ stopFireworksLoop(); }catch(e){};
  });
  document.getElementById('fw-lobby').addEventListener('click', ()=> {
    try{ localStorage.setItem('goLobbyNow', String(Date.now())); }catch(e){}
    try{ stopConfettiLoop(); }catch(e){}; try{ stopFireworksLoop(); }catch(e){};
    location.href = 'players.html';
  });
  }
  document.getElementById('fw-name').textContent = winner.name || `Jogador ${winner.id}`;
  document.getElementById('fw-pts').textContent = winner.pts;
  // ensure icon is up to date (in case player icons changed earlier)
  try{
    const fwIconEl2 = document.getElementById('fw-icon');
    const srcEl2 = document.getElementById(`player${winner.id}-icon`);
    if(fwIconEl2 && srcEl2 && srcEl2.src) fwIconEl2.src = srcEl2.src;
  }catch(e){}
  // Broadcast resultado para a outra tela (varia pelo timestamp para disparar 'storage')
  try{ localStorage.setItem('matchResult', JSON.stringify({ winnerId: winner.id, loserId: winner.id === 1 ? 2 : 1, pts: winner.pts, at: Date.now() })); }catch(e){}
  // Anima√ß√µes somente na tela do vencedor
  if(localPlayerId === winner.id){
    try{ startConfettiLoop(); }catch(e){ console.warn('confetti failed', e); }
    try{ startFireworksLoop(); }catch(e){ console.warn('fireworks failed', e); }
  }
}

// Modal de derrota (sem anima√ß√µes) com op√ß√£o de revanche
function showLoserModal(result){
  // Evita m√∫ltiplos
  if(document.getElementById('loserModal')) return;
  try{ if(timer){ clearInterval(timer); } }catch(e){}
  try{ if(spectatorTimer){ clearInterval(spectatorTimer); spectatorTimer = null; } }catch(e){}
  const overlay = document.createElement('div');
  overlay.id = 'loserModal';
  overlay.style.position = 'fixed';
  overlay.style.inset = '0';
  overlay.style.display = 'flex';
  overlay.style.alignItems = 'center';
  overlay.style.justifyContent = 'center';
  overlay.style.background = 'rgba(0,0,0,0.65)';
  overlay.style.zIndex = 10000;
  const content = document.createElement('div');
  content.className = 'fw-modal-content';
  content.innerHTML = `
    <img class="fw-modal-icon" src="" alt="√çcone do vencedor">
    <div style="text-align:left;min-width:0">
      <h2 style="margin:0 0 8px 0">Fim da Partida</h2>
      <p style="font-size:18px;margin:8px 0">Voc√™ perdeu. Vencedor: <strong id="loser-winner-name"></strong></p>
      <p style="margin:8px 0">Pontos do vencedor: <strong>${(result&&result.pts)||''}</strong></p>
      <div style="margin-top:12px;display:flex;gap:8px;justify-content:flex-start;flex-wrap:wrap;">
        <button id="rv-revanche" style="padding:8px 12px;border-radius:8px;border:none;background:#ff9f43;color:#1a1200;font-weight:600;cursor:pointer">Revanche</button>
        <button id="rv-lobby" style="padding:8px 12px;border-radius:8px;border:none;background:#5cb85c;color:#fff;cursor:pointer">Voltar ao Lobby</button>
      </div>
    </div>
  `;
  overlay.appendChild(content);
  document.body.appendChild(overlay);
  try{ setPowerTrayVisible(false); }catch(e){}
  try{
    const winnerId = (result && result.winnerId) || 1;
    const nameEl = document.getElementById('loser-winner-name');
    nameEl.textContent = document.getElementById(`player${winnerId}-name`).textContent || `Jogador ${winnerId}`;
    const icon = content.querySelector('.fw-modal-icon');
    const srcEl = document.getElementById(`player${winnerId}-icon`);
    if(icon && srcEl && srcEl.src) icon.src = srcEl.src;
  }catch(e){}
  document.getElementById('rv-revanche').addEventListener('click', ()=>{
    try{
      const toId = (result && result.winnerId) ? result.winnerId : (localPlayerId === 1 ? 2 : 1);
      const payload = { from: localPlayerId, to: toId, at: Date.now() };
      localStorage.setItem('rematchRequest', JSON.stringify(payload));
      // Mostra modal de aguardando resposta
      showRematchWaitingModal(toId);
      try{ startRematchTimeout(); }catch(e){}
    }catch(e){}
  });
  document.getElementById('rv-lobby').addEventListener('click', ()=>{
    try{ localStorage.setItem('goLobbyNow', String(Date.now())); }catch(e){}
    try{ stopConfettiLoop(); }catch(e){}
    try{ stopFireworksLoop(); }catch(e){}
    location.href = 'players.html';
  });
}

// Modal aguardando resposta do oponente
function showRematchWaitingModal(opponentId){
  try{ hideRematchModals(); }catch(e){}
  const overlay = document.createElement('div');
  overlay.id = 'rematchWaitingModal';
  overlay.style.position = 'fixed';
  overlay.style.inset = '0';
  overlay.style.display = 'flex';
  overlay.style.alignItems = 'center';
  overlay.style.justifyContent = 'center';
  overlay.style.background = 'rgba(0,0,0,0.65)';
  overlay.style.zIndex = 10001;
  const content = document.createElement('div');
  content.className = 'fw-modal-content';
  const oppName = (document.getElementById(`player${opponentId}-name`)||{}).textContent || `Jogador ${opponentId}`;
  content.innerHTML = `
    <div style="text-align:center;min-width:0">
      <h3 style="margin:0 0 8px 0">Solicitando revanche...</h3>
      <p style="margin:8px 0">Aguardando <strong>${oppName}</strong> aceitar ou recusar.</p>
      <p style="margin:8px 0;color:#bbb;font-size:14px">Se recusar, ambos voltar√£o ao lobby.</p>
    </div>`;
  overlay.appendChild(content);
  document.body.appendChild(overlay);
}

// Modal para o oponente aceitar/recusar
function showRematchPromptModal(requesterId){
  try{ hideRematchModals(); }catch(e){}
  const overlay = document.createElement('div');
  overlay.id = 'rematchPromptModal';
  overlay.style.position = 'fixed';
  overlay.style.inset = '0';
  overlay.style.display = 'flex';
  overlay.style.alignItems = 'center';
  overlay.style.justifyContent = 'center';
  overlay.style.background = 'rgba(0,0,0,0.65)';
  overlay.style.zIndex = 10001;
  const content = document.createElement('div');
  content.className = 'fw-modal-content';
  const reqName = (document.getElementById(`player${requesterId}-name`)||{}).textContent || `Jogador ${requesterId}`;
  content.innerHTML = `
    <div style="text-align:center;min-width:0">
      <h3 style="margin:0 0 8px 0">Revanche?</h3>
      <p style="margin:8px 0"><strong>${reqName}</strong> solicitou uma revanche.</p>
      <div style="margin-top:12px;display:flex;gap:8px;justify-content:center;flex-wrap:wrap;">
        <button id="rm-accept" style="padding:8px 12px;border-radius:8px;border:none;background:#1a4cd7;color:#fff;cursor:pointer">Aceitar</button>
        <button id="rm-decline" style="padding:8px 12px;border-radius:8px;border:none;background:#ff6b6b;color:#fff;cursor:pointer">Recusar</button>
      </div>
    </div>`;
  overlay.appendChild(content);
  document.body.appendChild(overlay);

  document.getElementById('rm-accept').addEventListener('click', ()=>{
    try{
      localStorage.setItem('rematchResponse', JSON.stringify({ accepted:true, by: localPlayerId, at: Date.now() }));
      localStorage.setItem('rematchNow', String(Date.now()));
    }catch(e){}
  });
  document.getElementById('rm-decline').addEventListener('click', ()=>{
    try{
      localStorage.setItem('rematchResponse', JSON.stringify({ accepted:false, by: localPlayerId, at: Date.now() }));
      localStorage.setItem('goLobbyNow', String(Date.now()));
    }catch(e){}
  });
}

function hideRematchModals(){
  try{ const a = document.getElementById('rematchWaitingModal'); if(a && a.parentNode) a.parentNode.removeChild(a); }catch(e){}
  try{ const b = document.getElementById('rematchPromptModal'); if(b && b.parentNode) b.parentNode.removeChild(b); }catch(e){}
}

function clearRematchTimeout(){
  try{ if(window._rematchTimeout){ clearTimeout(window._rematchTimeout); window._rematchTimeout = null; } }catch(e){}
}
function startRematchTimeout(){
  try{
    clearRematchTimeout();
    window._rematchTimeout = setTimeout(()=>{
      try{ localStorage.setItem('goLobbyNow', String(Date.now())); }catch(e){}
    }, 7000);
  }catch(e){}
}

function randomColor(){
  const palette = ['#FFD700','#FF5E5E','#5EE0FF','#8AFF8A','#C686FF','#FFB86B'];
  return palette[Math.floor(Math.random()*palette.length)];
}

function launchConfetti(count = 60){
  const container = document._confettiContainer || document.createElement('div');
  container.className = 'confetti-container';
  for(let i=0;i<count;i++){
    const c = document.createElement('div');
    c.className = 'confetti';
    const left = Math.random()*100;
    c.style.left = left + '%';
    c.style.background = randomColor();
    const dur = (Math.random()*1.6 + 1.2).toFixed(2) + 's';
    c.style.animationDuration = dur;
    c.style.animationDelay = (Math.random()*0.3)+'s';
    c.style.width = (6 + Math.random()*8) + 'px';
    c.style.height = (10 + Math.random()*18) + 'px';
    container.appendChild(c);
  setTimeout(()=>{ try{ if(c && c.parentNode) c.parentNode.removeChild(c); }catch(e){} }, (parseFloat(dur)*1000) + 500);
  }
  if(!document._confettiContainer){ document.body.appendChild(container); setTimeout(()=>{ try{ if(container && container.parentNode) container.parentNode.removeChild(container); }catch(e){} }, 4500); }
}

function startConfettiLoop(){
  if(window._confettiInterval) return;
  const container = document.createElement('div');
  container.className = 'confetti-container';
  document._confettiContainer = container;
  document.body.appendChild(container);

  function spawnBurst(){
    const burstCount = 6 + Math.floor(Math.random()*8);
    for(let i=0;i<burstCount;i++){
      const c = document.createElement('div');
      c.className = 'confetti';
      const left = Math.random()*100;
      const skew = (Math.random()*40 - 20);
      c.style.left = left + '%';
      c.style.background = randomColor();
      const dur = (1.3 + Math.random()*1.6).toFixed(2) + 's';
      c.style.animationDuration = dur;
      c.style.animationDelay = (Math.random()*0.25)+'s';
      c.style.width = (5 + Math.random()*10) + 'px';
      c.style.height = (10 + Math.random()*20) + 'px';
      
      c.style.transform = `translateX(${skew}px)`;
      container.appendChild(c);
      
      setTimeout(()=>{ try{ if(c && c.parentNode) c.parentNode.removeChild(c); }catch(e){} }, (parseFloat(dur)*1000) + 600);
    }
  }
  
  spawnBurst();
  window._confettiInterval = setInterval(()=>{
    spawnBurst();
  }, 800 + Math.floor(Math.random()*600));
}

function stopConfettiLoop(){
  try{
    if(window._confettiInterval){ clearInterval(window._confettiInterval); window._confettiInterval = null; }
    const c = document._confettiContainer;
    if(c && c.parentNode) c.parentNode.removeChild(c);
    document._confettiContainer = null;
  }catch(e){ console.warn('stopConfettiLoop error', e); }
}

/* Fireworks: DOM-based fireworks animation (non-blocking) */
function launchFireworks(count = 6, ascentDuration = 900){
  const container = document._fireworksContainer || document.createElement('div');
  if(!document._fireworksContainer){ container.className = 'fireworks-container'; document.body.appendChild(container); document._fireworksContainer = container; }
  const colors = ['#FFD700','#FF5E5E','#5EE0FF','#8AFF8A','#C686FF','#FFB86B','#FF9F43'];

  for(let i=0;i<count;i++){
    const leftPct = 8 + Math.random() * 84; // keep within 8%..92%
    const rocket = document.createElement('div');
    rocket.className = 'firework-rocket';
    rocket.style.left = leftPct + '%';
    rocket.style.animation = `fw-rocketUp ${ascentDuration}ms ease-out forwards`;
    document._fireworksContainer.appendChild(rocket);

    // explode after most of ascent
    setTimeout(()=>{
      try{
        const rect = rocket.getBoundingClientRect();
        const cx = rect.left + rect.width/2;
        const cy = rect.top + rect.height/2;
        const particles = 18 + Math.floor(Math.random()*8);
        for(let p=0;p<particles;p++){
          const part = document.createElement('div');
          part.className = 'firework-particle';
          const size = 6 + Math.floor(Math.random()*8);
          part.style.width = size + 'px'; part.style.height = size + 'px';
          const color = colors[Math.floor(Math.random()*colors.length)];
          part.style.background = color;
          // place at explosion center (convert to page coords)
          part.style.left = (cx - size/2) + 'px';
          part.style.top = (cy - size/2) + 'px';
          // random direction and distance
          const angle = Math.random()*Math.PI*2;
          const dist = 80 + Math.random()*220; // px
          const dx = Math.cos(angle) * dist;
          const dy = Math.sin(angle) * dist * -1; // upward bias
          part.style.setProperty('--dx', dx + 'px');
          part.style.setProperty('--dy', dy + 'px');
          const dur = 700 + Math.floor(Math.random()*900);
          part.style.animation = `fw-particleFly ${dur}ms cubic-bezier(.2,.6,.2,1) forwards`;
          document._fireworksContainer.appendChild(part);
          // remove after animation
          setTimeout(()=>{ try{ if(part && part.parentNode) part.parentNode.removeChild(part); }catch(e){} }, dur + 80);
        }
      }catch(e){ console.warn('firework explode error', e); }
      try{ if(rocket && rocket.parentNode) rocket.parentNode.removeChild(rocket); }catch(e){}
    }, Math.max(220, ascentDuration - 220));
  }
}

function startFireworksLoop(){
  if(window._fireworksInterval) return;
  launchFireworks(6, 900);
  window._fireworksInterval = setInterval(()=> launchFireworks(4 + Math.floor(Math.random()*6), 800 + Math.floor(Math.random()*600)), 1200 + Math.floor(Math.random()*800));
}

function stopFireworksLoop(){
  try{
    if(window._fireworksInterval){ clearInterval(window._fireworksInterval); window._fireworksInterval = null; }
    const c = document._fireworksContainer;
    if(c && c.parentNode) c.parentNode.removeChild(c);
    document._fireworksContainer = null;
  }catch(e){ console.warn('stopFireworksLoop error', e); }
}
</script>
<script>
(function(){
  const canvas = document.getElementById('backgroundCanvas');
  if(!canvas) return;
  const ctx = canvas.getContext('2d');
  const iconImages = [
    document.getElementById('icon-artes'),
    document.getElementById('icon-ciencia'),
    document.getElementById('icon-esportes'),
    document.getElementById('icon-mundo'),
    document.getElementById('icon-variedades'),
    document.getElementById('icon-sociedade')
  ];
  const iconSize = 40; const spacing = 20; const icons = []; const speed = 0.2;
  function initIcons(){
    const cols = Math.ceil(canvas.width / (iconSize + spacing));
    const rows = Math.ceil(canvas.height / (iconSize + spacing));
    for(let row=0; row<rows; row++){
      for(let col=0; col<cols; col++){
        const iconIndex = (row + col) % iconImages.length;
        icons.push({ img: iconImages[iconIndex], x: col * (iconSize + spacing) + spacing/2, y: row * (iconSize + spacing) + spacing/2 });
      }
    }
  }
  function animate(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    icons.forEach(icon=>{
      icon.x += speed; if(icon.x > canvas.width) icon.x = -iconSize;
      try{ ctx.drawImage(icon.img, icon.x, icon.y, iconSize, iconSize); }catch(e){}
    });
    requestAnimationFrame(animate);
  }
  function startAnimation(){ canvas.width = window.innerWidth; canvas.height = window.innerHeight; icons.length = 0; initIcons(); animate(); }
  Promise.all(iconImages.map(img=>new Promise(resolve=>{ if(img.complete) resolve(); else { img.onload = resolve; img.onerror = resolve; } }))).then(startAnimation);
  window.addEventListener('resize', startAnimation);
})();
</script>
</body>
</html>
